# Nucleo_git [multitasking]
 STM32-Nucleo-github

 22мар22
 @Biriuk
 peotr60@mail.ru
 
 Изучение микроконтроллера STM32 в среде STM32CubeIDE с помощью библиотеки HAL
 с использованием отладочной платы NUCLEO-L452RE-P
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ВНИМАНИЕ!
  При использовании RTC в библиотеке HAL имеется серьёзный баг, который можно обойти следующим образом:
  В файле stm32l4xx_hal_rtc.c (Drivers / Src / stm32l4xx_hal_rtc.c) закомментировать строку:
  
  1560	// sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
  
  При этом следует иметь в виду, что каждый раз после пересборки проекта придётся каждый раз
  закоментировать эту строку вручную.
  
  Баг в данном скетче выглядел следующим образом:
  
  1. Реальное время не изменялось, равнялось нолю.
  2. В случае, если в таск StartMonitorTask записать строку:
  HAL_RTC_SetTime(&hrtc, &nTime, RTC_FORMAT_BIN);
  то показания реального времени соответствовали требуемым, однако, настройка пина PC13 
  непостижимым образом сбивалась, что приводило к установке на нём низкого уровня, соответственно,
  к невозможности управления программными процессами от штатной кнопки B1_Blue. Далее, после 
  отключения/включения питания на пине вообще уровень менялся какими-то пачками импульсов высокой 
  частоты.
  Т.е. в случае использования в таске или подпрограмме, где измеряется реальное время, строки
  HAL_RTC_SetTime(&hrtc, &nTime, RTC_FORMAT_BIN);
  пин PC13 использовать НЕЛЬЗЯ!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 Этот код сохраняется в  GitHub по адресу:
 https://github.com/Peotr-B/Nucleo_git.git
 =============================================================================================
 
 Описание программы
 Здесь как правило в учебных программах функционирует контрольная индикация штатной работы программы
 встроееным светодиодом LD4_Pin и выводом сообщений на терминал ПК через USB в задаче StartDefaultTask
 Кроме того, по обыкновению сообщения дублируются через канал SWO на отладчик STM32 ST-LINK
 с помощью команд printf и puts, для функциональности которых в main.c вносятся следующие операторы:
 *****************************************************************************************************
  /* USER CODE BEGIN 4 */
//это стандартна¤ запись для посимвольного вывода информации в интерфейс ITM в среде STM32CubeIDE
//(должно быть в случае применени¤ SWO)
//https://www.youtube.com/watch?v=nE-YrKpWjso&list=PL9lkEHy8EJU8a_bqiJXwGTo-uM_cPa98P
int __io_putchar(int ch)
{
	ITM_SendChar(ch);
	return ch;
}

//или:

//STM32: отладка через SWO в STM32CubeIDE с доработкой ST-LINK
//https://www.youtube.com/watch?v=ST_fUu6ACzE
//https://www.youtube.com/watch?v=iC2-0Md-6yg

//int _write(int file, char *ptr, int len)
 //{
 //int i = 0;
 //for(i = 0; i < len; i++)
    //ITM_SendChar((*ptr++));
 //return len;
 //}

/* USER CODE END 4 */
 ****************************************************************************************************
  Далее. В программе имеются следующие задачи (таски):
 
 1. DefaultTask
 В этой задаче производится мигание штатного светодиода с периодом 500 мс. При нажатии штатной кнопки
 период мигания уменьшается до 100 мс.
 
 2. BtnTask
 В этой задаче сигнал от кнопки управляет частотой мигания штатного светодиода и посылается в очередь
 QueueData для вывода состояния кнопки на монитор ПК
 
 3. PWM_Task
 В этой задаче вырабатывается и подаётся на пин PC6 сигнал PWM
 
 4. INGPIO_Task
 В этой задаче в очередь QueueData посылается сигнал с пина PC8, на который можно подать, например, сигнал
 с пина PC6 с помощью джампера
 
 5. GetQuTask
 В этой задаче производится вывод на монитор ПК информации, полученной из очереди QueueData
 
 6. MonitorTask
 В этой задаче производится вывод на монитор ПК значения реального времени работы программы
 
 Кроме того, для обеспечения надёжного вывода информации на монитор ПК, что занимает значительное время,
 применён мьютекс MutexMonitor в задачах GetQuTask и MonitorTask
 =============================================================================================
 
 24мар22
 Включил счётчик времени работы программы в формате ч:м:с
 Почему-то время в часах начинается с "1". Несколько раз засекал значения секунд более 60,
 например, 64. Поменял формат с BCD на BIN, кстати, о похожей проблеме с форматами указывал:
 --------------------------------------------------
 Аноним Ананомный
 а у меня в одной минуте аж 90 сек. что за дела? 
 ПОСТАВИЛ БИНАРНЫЙ ФОРМАТ И ВСЕ ЗАРАБОТАЛО!
 https://www.youtube.com/watch?v=0CaETEzPh0g
 --------------------------------------------------
 После смены формата минуты и секунды работают нормально. Но часы надо предустанавливать на "23", 
 чтобы получить "0" после непонятного инкремента в момент считывания времени (см. библиотеку HAL RTC):
 --------------------------------------------------
 HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
 {...
 sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 (здесь уже на единицу больше, но это происходит однократно)
 sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
  }
 --------------------------------------------------- 
 Увеличил минимальный стек под задачи (MINIMAL_STACK_SIZE) с 128 до 256 в Config parameters
 Не помогло.
 Разбираюсь с проблемой дальше.
 --------------------------------------------------
 25мар22
 Также следует обратить внимание на следующие посты:
  
 Pavel San
 Как при подключении кварца 32КГц управлять светодиодом на PC13?
 
 Александр Ларюшкин
 Вверху просто надо в параметре RTC OUT вместо Disable поставить No RTC Output. 
 Но надо еще читать Errata, т.к. у некоторых МК при использовании PC13 могут быть проблемы с точностью RTC. 
 https://www.youtube.com/watch?v=3Fkhim7chTk
 
 -------------------------------------------------------------------------------------
 26мар22
 К существующей задаче StartDefaultTask, в которой организовано мигание светодиодом и вывод на монитор
 времени работы программы, добавил следующие две задачи:
 BtnTask - считывание сигнала от кнопки
 MonitorTask - управление выводом информации  на монитор о состоянии кнопки
               - очередь
 Задал кооперативную (не вытесняющую) многозадачность, при которой в конце кода задачи мы должны явно вызвать 
 планировщик при помощи функции osThreadYield(). 
 
 Для настройки  кооперативной многозадачности необходимо в окне MX:
 Middleware / FREERTOS / Config parameters / 
 в USE_PREEMPTION установить Disabled
 
 Примечание. 
 Можно установить значение "0" в строке define configUSE_PREEMPTION в файле FreeRTOSConfig.h:
 
 62. #define configUSE_PREEMPTION      0
 
 Этот файл находится  в окне Project Explorer: Core\Inc\FreeRTOS.h, или на диске: 
 D:\STM32\STM32_File\Nucleo_git\Core\Inc
 См.:
 [FreeRTOS Learning 05] Глубокая анатомия FreeRTOSConfig.h для реализации индивидуальной настройки системы
 https://russianblogs.com/article/50011436450/

 ОДНАКО! При пересборке проекта восстановится значение "1". 
 ПОЭТОМУ! Устанавливать значение этого параметра нужно ТОЛЬКО в окне MX.

 -------------------------------------------------------------------------------------
 31мар22
 Сегодня добавил задачи: 
 PWM_TaskHandle для организации вывода сигнала PWM на порт PC6
 -------------------------------------------------------------------------------------
 2апр22
 Сегодня добавил сигналы GPIO на портах PC6, PC8. 
 Во вкладке TIM3 в опции NVIC отаметил  Setting TIM3 global interrupt, и после 
 перекомпоновки проекта стала ругаться RTOS. 
 Понял, что так просто применить прерывания в случае использования RTOS не получится.
 Отменил прерывание по TIM3.
 -------------------------------------------------------------------------------------
  3апр22
 ВНИМАНИЕ! Логика кооперативной многозадачности плохо работает для большинства типовых задач.
 В соответствии с этим, решил отказаться от кооперативной многозадачности, и применить ГИБРИДНУЮ
 многозадачность, используя КРИТИЧЕСКИЕ СЕКЦИИ для требующих непрерывного полного завершения
 фрагментов задач.
 
 -------------------------------------------------------------------------------------
 6апр22
 В ходе изучения корпоративной многозадачности выяснил, что применять её можно только
 в случае крайней необходимости или для фрагментов задач с коротким временным интервалом
 с применением выесняющей многозадачности, но использованием функций типа
 taskENTER_CRITICAL() --- taskEXIT_CRITICAL() и vTaskSuspendAll() --- xTaskResumeAll().
 Подробнее можно прочитать здесь:
 [4.2. Критические секции и приостановка шедулера]
 http://microsin.net/programming/arm/freertos-part4.html
 
 Поэтому, в данном примере решил использовать мьютексы для затратных по времени задач
 
 -------------------------------------------------------------------------------------
 6апр22
 ВНИМАНИЕ!
 Обратил внимание, что при запуске окна CubeMX на FREERTOS в окне Categories появляется
 красный крестик в кружочке. После чего, нашёл во вкладке FreeRTOS Heap Usage в строке 
 HEAP STILL ABAILABLE отрицательное значение Bytes! Тогда я на вкладке Config parameters
 увеличил значение TOTAL_HEAP_SIZE, в моём случае до 12000 Bytes. После чего значков ошибок
 не появлялось, более того, без последствий вернул Memory Management scheme на heap_4 
 (что было по умолчанию).
 ************************************************************************************************************ 
 
 Этапы изучения (по аналогии с "FreeRTOS для чайников. Краткое описание"
 http://easyelectronics.ru/freertos_manual.html)
 
 1. Задачи. Создание задач
 2. Очереди. Обмен данными между задачами
 3. Семафоры
 4. Mutex
 5. Системный таймер
 6. Диспетчер и Многозадачность
 7. Таймауты, обработка ошибок, и что же не так с прерываниями? Команда taskYIELD
 8. Работа freeRTOS с прерываниями
 9. Сопрограммы aka Co-Routines
 
 За основу взят материал:
  STM32 с нуля. FreeRTOS. Кооперативная многозадачность
  https://microtechnics.ru/stm32-uchebnyj-kurs-freertos-chast-3/
  
  Функция библиотеки STM32CubeIDE HAL управляет часами реального времени RTC и прерыванием сигнала тревоги таймера
  https://russianblogs.com/article/7849848366/
  
  МГТУ пМ. Н.Э.БАУМАНА
  Лекция-практикум "SM32CubeIDE + FreeRTOS. Примеры задач, очереди, семафоров"
  Vladimir Leonidov [BMSTU]
  https://www.youtube.com/watch?v=JKkyF53AAM4
  Lab 7 - FreeRTOS
    
  Проект RTOS_1
  
 STM32 и CubeIDE: ШИМ и светодиод
 https://robotclass.ru/tutorials/stm32-cubeide-pwm/
 
 STM Урок 10. HAL. Изучаем PWM (ШИМ). Мигаем светодиодами плавно
 https://narodstream.ru/stm-urok-10-hal-izuchaem-pwm-shim-migaem-svetodiodami-plavno/
 
 STM32. PWM на практике. Проверяем себя осциллографом. Переходим с Arduino на STM32
 https://www.youtube.com/watch?v=ZEdIQvwIpaM&t=2s
 https://github.com/Solderingironspb/Lessons-Stm32.git
 
 Урок 8. Управление портами ввода-вывода через функции библиотеки HAL
 http://mypractic.ru/urok-8-upravlenie-portami-vvoda-vyvoda-cherez-funkcii-biblioteki-hal.html
 
 FreeRTOS: практическое применение, часть 4 (управление ресурсами) 
 http://microsin.net/programming/arm/freertos-part4.html
 -------------------------------------------------------------------------------------
 
 В ходе разработки использовалось:
 
 STM32 + FreeRTOS
 http://we.easyelectronics.ru/STM32/stm32-freertos.html
 
 Nucleo_git от 5мар22 (управление очередями)
 
 Nucleo_git от 14мар22 (использование мьютексов)
 
 Урок №3. Использование системы FreeRTOS на примере работы кнопки и 
 светодиода с помощью микроконтроллера STM32F103:
 https://texnohelp.com/stm32-freertos-lesson3/
 
 а также:
 
 FreeRTOS для чайников. Краткое описание
 http://easyelectronics.ru/freertos_manual.html

 [STM32L4] Очередь сообщений FreeRTOS для приема и отправки трех последовательных портов
 https://russianblogs.com/article/88161192459/
 
 Старт ARM. RTOS часть 5-ая. Мьютексы
 https://www.mcu.by/%D1%81%D1%82%D0%B0%D1%80%D1%82-arm-rtos-%D1%87%D0%B0%D1%81%D1%82%D1%8C-5-%D0%B0%D1%8F-%D0%BC%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81%D1%8B/

 Использование CMSIS-RTOS
 https://russianblogs.com/article/8958290203/

 FreeRTOS Приоритизация и алгоритмы управления диспетчером задач. Вытесняющий и кооперативный режимы
 https://www.youtube.com/watch?v=VuyL0sCVPk8

 Микроконтроллеры STM32: использование встроенных RTC
 https://eax.me/stm32-rtc/
 
 RTC HAL stm32
 https://istarik.ru/blog/stm32/116.html

 Использование CMSIS-RTOS
 https://russianblogs.com/article/8958290203/

 FreeRTOS Приоритизация и алгоритмы управления диспетчером задач. Вытесняющий и кооперативный режимы
 https://www.youtube.com/watch?v=VuyL0sCVPk8
 
 кроме того:
 
 STM32CubeMx. Быстрый старт с FreeRTOS для STM32
 https://microtechnics.ru/stm32cubemx-bystryj-start-s-freertos-dlya-stm32/
 
 STM32 с нуля. FreeRTOS. Типы многозадачности, пример программы
 https://microtechnics.ru/stm32-uchebnyj-kurs-freertos-chast-2/
 
 STM32 с нуля. FreeRTOS. Кооперативная многозадачность
 https://microtechnics.ru/stm32-uchebnyj-kurs-freertos-chast-3/
 
 FreeRTOS: практическое применение
 http://microsin.net/programming/arm/freertos-part1.html
 http://microsin.net/programming/arm/freertos-part2.html
 
 START: Создание проекта с STM32 Cube MX и FreeRTOS для Atollic TrueSTUDIO
 http://www.milbestore.ru/article/sozdanie-proekta-s-stm32-cube-mx-i-freertos-dlya-atollic-truestudio
 
 STM32CubeIDE. Установка, настройка и отладка. Часть 1
 https://www.youtube.com/watch?v=6xhzoDGi4qA
 
 STM32CubeIDE. Как сделать: Использование отладчика
 https://www.youtube.com/watch?v=PSiq8-DFxYU
 
 CMSIS-RTOS2  Version 2.1.3
 https://arm-software.github.io/CMSIS_5/RTOS2/html/group__CMSIS__RTOS__TimerMgmt.html#ga7dc24a4c2b90334427081c3da7a71915
 https://arm--software-github-io.translate.goog/CMSIS_5/RTOS2/html/group__CMSIS__RTOS__TimerMgmt.html?_x_tr_sl=auto&_x_tr_tl=ru&_x_tr_hl=ru#ga7dc24a4c2b90334427081c3da7a71915

 CMSIS-RTOS ДЛЯ МИКРОКОНТРОЛЛЕРОВ С ЯДРОМ CORTEX-M3
 http://repo.ssau.ru/bitstream/Metodicheskie-izdaniya/CMSISRTOS-dlya-mikrokontrollerov-s-yadrom-CortexM3-metod-ukazaniya-k-lab-rabote-Tekst-elektronnyi-87343/1/CMSIS-RTOS%20%D0%B4%D0%BB%D1%8F%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%BE%D0%B2%20%D1%81%20%D1%8F%D0%B4%D1%80%D0%BE%D0%BC%202020.pdf
 
 STM32CubeIDE. Установка, настройка и отладка. Часть 1
 https://www.youtube.com/watch?v=6xhzoDGi4qA
 
 STM32CubeIDE. Как сделать: Использование отладчика
 https://www.youtube.com/watch?v=PSiq8-DFxYU
 